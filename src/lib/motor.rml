open Types
open Utils
open Time
open Osc

(* ---------------------------------------------------------------- *)
(*                      Player Definition                           *)
(* ---------------------------------------------------------------- *)

let make_player tic score input output events =

    (* run_intervals inter_l *)
    let process run_intervals inter_l =
        let process run_rigid d s =
          run (wait tic d); emit s
        in
        let process handle_duration d =
        match d with
            | Finite (f,s) -> run (run_rigid f s)
            | Infinite s -> do pause until s done
        in
        run (Rml_list.par_iter
                (proc i ->
                    match i with
                        | Rigid (d,s) ->
                            run (run_rigid d s)
                        | Flexible (min,max,_) ->
                            let (min_d,min_s) = min in
                            begin
                                run (run_rigid min_d min_s);
                                run (handle_duration max);
                            end

                )
                inter_l
            )
    in

    (* wait_intervals inter_l *)
    let process wait_intervals inter_l id_box=
        (* sync_minimum inter_l *)
        let process sync_minimum inter_l =
            run (Rml_list.par_iter
                    (proc i ->
                        match i with
                            | Rigid (d,s) -> (* synchronization fixed intervals *)
                                await immediate s
                            | Flexible (min,_,_) ->
                                let (min_d,min_s) = min in
                                await immediate min_s
                    )
                    inter_l
                )
        in

        let checkIP ip input =
            List.exists (fun i -> ip = i) input
        in

        if (List.length inter_l > 0) then  (* if the box is not the scenario *)
        begin
            run (sync_minimum inter_l); (* synchronization of minimum durations *)
            match (List.hd inter_l) with
                | Rigid (_) ->  ()  (* There is not maximum durations *)
                | Flexible (_,max,ip) -> (* Handling Interaction Point *)
                  begin
                        let max_s =
                        begin match max with
                            | Finite (d,s) -> s
                            | Infinite s -> s
                        end in
                        print_endline ("start IP_Handling of Box "^(string_of_int id_box));
                        emit events (IP_START id_box);
                        do
                            loop
                                await input (ip_e) in (* only one event each time unit *)
                                (if (checkIP ip ip_e) then emit max_s);
                                pause
                            end
                        until max_s done;
                        print_endline ("End IP_Handling of Box "^(string_of_int id_box))
                    end
        end

    in

    let rec process run_generic box w_rels s_rels stop_f id_box =

        let process run_boxes_par boxes relations stop =
            run (Rml_list.par_iter
                (proc b ->
                    let ident =
                    begin match b with
                    | Structure (i,_,_,_) -> i
                    | Texture (i,_,_,_) -> i
                    end in
                    (*let (id_b,_) = b in*)
                    run (run_generic b (get_intervals ident relations To) (get_intervals ident relations From) stop ident)
                )
                boxes
            )

        in

        let process run_p_box p_box =
            let (ident, interval,star_m,end_m) = p_box in
            print_endline ("Start Texture ("^(string_of_int ident)^")");
            do
                emit output (star_m);
                (run (run_intervals [interval]) || run (wait_intervals [interval] ident));
                emit output (end_m);
            until stop_f -> emit output (end_m) done;
            print_endline ("End Texture ("^(string_of_int ident)^")");

        in

        let process run_h_box h_box =
            let (ident, boxes, relations, interval) = h_box in
            signal stop_box_h in
            signal kill_m in
            print_endline ("Start Structure ("^(string_of_int ident)^")");
            (
            (* wait for pre-emption *)
            do (await immediate stop_f; (print_endline "father deleted"); emit stop_box_h) until kill_m done ||

            (((do
                (* run duration signal *)
                run (run_intervals [interval]) ||

                (* wait duration of the box *)
                (run (wait_intervals [interval] ident);
                    begin
                        match interval with
                        | Rigid _ -> ()
                        | Flexible _ -> emit stop_box_h
                    end
                ) ||

                (* run internal relations *)
                run (run_intervals (get_intervals ident relations From)) ||

                (* wait end -> synchronization *)
                run (wait_intervals (get_intervals ident relations To) ident)

            until stop_box_h done); emit stop_box_h; emit events (BOX_END id_box)) ||

            (* run boxes *)
            run (run_boxes_par boxes relations stop_box_h)); emit kill_m
            );
            print_endline ("End Structure ("^(string_of_int ident)^")")

        in

        let process run_box box =
            match box with
            | Structure h -> run (run_h_box h) (* run Structure box *)
            | Texture p -> run (run_p_box p) (* run Texture *)

        in

        (* wait preceding intervals *)
        run (killable_p (wait_intervals w_rels id_box) stop_f);

        (* execute box *)
        emit events (BOX_START id_box);
        run (run_box box);
        emit events (BOX_END id_box);

        (* send precendet intervals*)
        run (killable_p (run_intervals s_rels) stop_f)

    in

    let process play score =
        signal stop_scr in
        match score with
            | Structure (id,_,_,_) ->
                print_endline "start scenario";
                run (run_generic score [] [] stop_scr id);
                print_endline "End scenario"
            | _ -> print_endline "The scenario must be a Structure box."
    in

    play score
